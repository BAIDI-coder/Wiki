{"pages":[{"title":"About","date":"2020-11-06T08:23:20.868Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-11-06T08:23:20.872Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-11-06T08:23:20.879Z","path":"tags/index.html","text":""}],"posts":[{"title":"","date":"2020-11-06T08:35:32.784Z","path":"wiki/小技巧手册/","text":"每天一个避坑小技巧 解决网站元素（例如图片）加载不出来的方法 浏览器下审查该元素的URL地址，然后在搜索他的域名对应的地址（https://tools.ipip.net/domain.php） 将域名解析 “xxx.xxx.xxx.xxx 域名” 加入到hosts文件中（一般在 %SystemRoot%\\system32\\drivers\\etc\\ 目录下） cmd 下 ipconfig \\flushdns 刷新试试 刷新浏览器查看效果 SSR 解决端口占用问题： 法一：在 SSR 选项设置里改变端口 法二：taskkill /pid xxx -f cmd 管理 Process tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process 找到占用端口的进程号：netstat -aon|findstr &quot;59207&quot; 查看进程所对应的应用程序：tasklist|findstr &quot;1396&quot; Powershell、cmd 终端显示编码方式 chcp + (num) 临时更改编码 437（英语） 65001（utf-8） 936（GBK） posh 重定向编码方式 默认编码：UTF-16LE 修改方式：&lt;your command&gt; | out-file 1.txt -encoding utf8 vscode 修改终端字体：用户设置（json）terminal.integrated.fontFamily 字段","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.782Z","path":"wiki/微积分复习纲要/","text":"微积分复习纲要复习重点微分方程 二阶微分方程的特解形式 空间向量与空间几何多元函数微分学 几何应用：求不同类型曲面曲线的几何量 连续，可微，可导以及方向导数之间的关系 极值与最值 隐函数的导数 重积分 曲面面积的公式$\\int\\int$ 曲线积分与曲面积分 平面/空间曲线积分与路径无关的4个等价条件 格林公式/斯托克斯公式 高斯公式 第二型与第一型的关系与转换 场论初步 无穷级数","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.781Z","path":"wiki/面向序列标注的方法与应用研究/","text":"1. 绪论​ 从文本翻译到文字、语音识别，再到命名实体识别，词性标注，序列标注问题已然渗透到社会生活中的方方面面。不少自然语言处理的问题都可以想方设法转化为序列标注问题：对邮件等”大块“的信息做命名实体识别，识别出信息中的表单项用于自动填写表单，可以有效地提高工作效率，节约时间；对音频文件进行标注分析，可以用来进行语音识别；抽取出来的电子病历文本中的疾病、治疗、检查等类型的实体，可以用以对电子病历进行分类归档……想要处理好一般性的自然语言处理问题到序列标记问题的转化，关键在于处理好如何定义标记的问题。 ​ 作为自然语言处理中常见的问题之一，序列标注问题已经由来已久，并在经历了一系列的发展变革后逐渐壮大健全。最早的有传统的隐马尔可夫模型、最大熵模型和条件随机场模型，最大熵模型抛弃了隐马尔科夫模型的独立输出假设，而条件随机场模型又在最大熵模型的基础上进一步将标签的转移扩大为全局特征，使得上下文之间的联系更加紧密。无论是在理论还是实践结果上来看，条件随机场的整体效果都要优于前两种方法。步入深度学习发展的时代后，新的诸如$RNN$和$LSTM$模型也相继用于序列标注问题，有效地改善了传统方法在处理更长的上下文依赖、过拟合、依赖启发式知识等方面的不足之处。本文主要研究和探讨了传统的序列标注模型——隐马尔可夫模型和条件随机场模型——的理论基础和应用实践。 2. 正文2.1 定义​ 序列标注是指将输入的一串观测序列 $x_1x_2x_3…x_n$ 转化为一串标记序列 $y_1y_2y_3…y_n$ 的过程，要解决序列标记问题，实际上就是要找到一个观测序列到标记序列的映射 $f(x_i)\\rightarrow y_i\\space (i=1,2,…,n)$。 2.2 HMM模型2.2.1 马尔可夫链​ 马尔可夫链（Markov chain），又称离散时间马尔可夫链，为状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。 ​ 从数学形式上来看，对于随机变量序列$X_1X_2X_3…X_n$，满足$$P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3…,X_{n-1}=x_{n-1})=P(X_n=x_n|X_{n-1}=x_{n-1})$$，则称该序列为一个一阶马尔可夫链。 ​ 从宏观意义上来看，Markov链说明了在状态转移过程中，“未来”与“过去”无关而只与“现在”有关。 ​ Markov链常常被认为是时齐的，即转移概率与n无关。 ​ 类似的可以定义m阶Markov链，满足$$\\begin{aligned}&amp;P(X_n=x_n|X_1=x_1,X_2=x_2,X_3=x_3…,X_{n-1}=x_{n-1})\\=&amp;P(X_n=x_n|X_{n-m}=x_{n-m},X_{n-m+1}=x_{n-m+1}…,X_{n-1}=x_{n-1})\\end{aligned}$$ 2.2.2 隐马尔可夫模型​ 隐马尔可夫模型（Hidden Markov Model 缩写：HMM）基于Markov链，不同与一般的Markov链，HMM 又加入了隐变量这一概念，即该模型包含了观测序列$X_1X_2X_3…X_n$和与它一一对应的标记序列$Y_1Y_2Y_3…Y_n$。该模型用到了两个基本假设： 时齐的Markov性假设，如2.2.1所述 独立输出假设，输出状态的概率仅与输入状态相关，而与输入序列的前后文无关 以图形表示的隐马尔可夫模型如下所示： HMM 模型解决了被用来解决序列标注问题中的三个基本问题：预测、平滑和解码。本文主要讨论的解码问题，即求解给定观测序列，给出最有可能的标记序列的问题。本文使用$\\lambda(W,T,\\pi,\\beta,A,B)$来表征一个序列标注问题的HMM模型，其中$W$表示观测序列，$T$表示输出的标记序列，$\\pi$表示标记之间的概率转移转移矩阵，$\\beta$表示标记到观测值的发射概率，$A$表示输入对象的集合，$B$表示标记的集合。 2.2.3 概率模型问题归结于求解下式$$arg_{T}max\\space P(T=t_1t_2…t_n|W=w_1w_2…w_n,\\lambda)\\qquad (t_i\\in B, w_i\\in A)\\tag{1}$$由贝叶斯概率公式$$P(T|W)=\\frac{P(W|T)P(T)}{P(W)}\\propto P(W|T)P(T)\\tag{2}$$因为 $P(W)=const$ 故而可以省略不予以考虑 由独立输出假设可知$$P(W|T)=P(w_1|t_1)P(w_2|t_2)…P(w_n|t_n)\\tag{3}$$由一阶时齐的Markov性假设可知$$P(T)=P(t_1)P(t_2|t_1)P(t_3|t_2)…P(t_{n}|t_{n-1})\\tag{4}$$联立方程 $(2)(3)(4)\\Rightarrow$$$P(T|W)\\sim [P(t_1)P(w_1|t_1)][P(t_2|t_1)P(w_2|t_2)]…[P(t_n|t_n-1)P(w_n|t_n)]\\tag{5}$$其中转移概率由条件概率公式可知$$P(t_i|t_{i-1})=\\frac{P(t_i,t_{i-1})}{P(t_{i-1})}\\tag{6}$$等式$(6)$中标记值的概率和等式$(5)$中的独立输出概率可由统计方法或规则方法得出，下面介绍两种方法的异同： 项目 统计方法 规则方法 介绍 通过统计得出频率估计概率的方法 通过既定的规则来估计概率的方法 优点 覆盖面广，稳定性高 精确，对于特殊现象的支持度好 缺点 对于特殊现象的支持度差 规则库庞大，编写和维护复杂，覆盖面不及统计方法 能够计算出特定$T^*$的概率值$P(T^*|W)$还不够，还要要找到最大的概率对应的$T$。这个问题可以转化成一个求解最短加权路径的图论问题。 可构建像 graph 1 所示的图模型（其余路径未画出）。显然，如果标记的取值有$m$种可能，序列的长度为$n$，那么枚举所有路径然后取加权值最大的路径的算法复杂度为 $O(n^m)$ ，随着序列长度增长而呈指数级增长。为了降低复杂度这里一般采用维特比算法 (Viterbi algorithm) 。 The Viterbi algorithm is a dynamic programming algorithm for finding the most likely sequence of hidden states—called the Viterbi path—that results in a sequence of observed events, especially in the context of Markov information sources and hidden Markov models (HMM).^[2] 维特比算法是一种动态规划算法，用于找出隐藏的最大可能路径（维特比路径）。维特比算法的核心思想在于全局最优包含局部最优。考虑从起点到某个中间点的最大加权路径，那么该路径所经过的该中间点的前一个点在同时间上所有点中也一定是加权最大的点。下面给出了Viterbi算法的伪代码。其中$T_1,T_2$分别为保存当前节点最大累计权值的矩阵和保存该节点最大累计权值路径上的上一个节点的矩阵。以下给出了维特比算法的算法伪代码： 下溢问题：$(5)$ 式中的连乘积中因子有可能过小而下溢为零从而造成整个式子变为0，为了避免这种情况可以考虑取对数化乘积为加法的技巧。 2.2.4 应用​ 绝大多数自然语言处理问题（Natural Language Processing Problem，简称NLP问题），都可以转化为一个序列标注问题。想要处理好NLP问题到序列标记问题的转化关键在于处理好如何定义标记的问题。例如对于中文分词问题，可以定义标签集合 $T={B,M,E,S}$ ，其中 $B(begin),M(middle),E(end),S(single)$ 分别表示词的开头，中间，结尾和单个字成词；对于词性标注问题，可以在分词处理的基础上让一个词对应一个词性标签。对于命名实体识别问题，可以定义标签集合 $T={BL,ML,EL,BP,MP,EP,BO,MO,EO,N}$ 其中 $B,M,E$ 后面跟着的 $L(location),P(person),O(organization)$ 分别表示地名，人民，机构名，而 $N$ 表示不属于实体的部分。定义好标记之后输入训练好的模型后问题即可求解。 2.3 CRF 模型2.3.1 随机场、马尔可夫随机场、条件随机场​ 考虑一个空间内各个区域按照某种分布被赋予了某个随机值，这样的场称之为“随机场”。而马尔可夫随机场则是一类特殊的随机场，场中每个点的赋值不仅与自身位置有关，还和相邻位置的赋值相关。如果考虑马尔科夫性的同时将点的赋值概率看做是条件概率，则称该马尔科夫场为条件随机场（Conditional random fields 简称：CRF）。如维基百科中所述^3: Whereas a classifier predicts a label for a single sample without considering “neighboring” samples, a CRF can take context into account. ​ CRF模型和那些仅仅只考虑自身来进行分类的模型不同之处就在于CRF模型将样本点的“邻居”也考虑在内，这个特点使得CRF模型有能力处理上下文有关联的序列标注的问题。 2.3.2 线性链条件随机场线性链的条件随机场（Linear conditional random fields）是对条件随机场的简化模型：$X=(X1,X2,…Xn),Y=(Y1,Y2,…Yn)$ 均为线性链表示的随机变量序列，在给定随机变量序列$X$的情况下，随机变量$Y$的条件概率分布 $P(Y|X)$ 构成条件随机场，即满足马尔科夫性：$$P(Yi|X,Y1,Y2,…Yn)=P(Yi|X,Yi−1,Yi+1)\\tag{7}$$则称 $P(Y|X)$ 为线性链条件随机场。 2.3.3 概率模型​ 为了建立可供学习的CRF模型，可以定义两类特征函数（这些特征函数用来评价一个序列在某些特征方面是否“靠谱”，只有 $1, 0$ 两种取值，即判断是否满足条件）：一类只与当前节点有关，表示为$s_l(y_i,x,i)\\space (l=1,2…,m)$；另一类还与前一个节点有关，表示为$t_k(y_{i-1},y_i,x,i)\\space (k=1,2…,n)$。引入需要学习的权重参数（所谓“权重”即用来衡量一个判断依据的重要程度的参数）$\\lambda_l,\\mu_k$，则条件概率表示为$$\\begin{aligned}P(y|x)&amp;=\\frac{1}{Z(x)}exp(\\sum_{i,k}λkt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μls_l(y_i,x,i))\\&amp;\\propto exp(\\sum{i,k}λ_kt_k(y{i−1},y_i,x,i)+\\sum_{i,l}μls_l(y_i,x,i))\\end{aligned}\\tag{8}$$$Z(x)$为规范化因子，是所有可能的标注序列的概率和，使得等式右边规范为一个概率。$$Z(x)=\\sum{y}exp(\\sum_{i,k}λkt_k(y_{i−1},y_i,x,i)+\\sum_{i,l}μls_l(y_i,x,i))\\tag{9}$$为了使得表示更加方便，将参数 $\\lambda,\\mu$ 均表示为 $w$ ，特征函数 $t, s$ 均表示为 $f$ ，即有$$w{k}=\\left{\\begin{aligned}&amp;\\lambda_k\\qquad &amp;(0 &lt; k \\leqslant m)\\&amp;\\mu_{k-m}\\qquad &amp;(m &lt; k \\leqslant m+n)\\end{aligned}\\tag{10}\\right.$$$$f{k}(y,x)=\\left{\\begin{aligned}&amp;\\sum_{i}s_k(y_i,x,i)\\qquad &amp;(0 &lt; k \\leqslant m)\\&amp;\\sum_{i}t_{k-m}(y_{i-1},y_i,x,i)\\qquad &amp;(m &lt; k \\leqslant m+n)\\end{aligned}\\tag{11}\\right.$$ 由 $(11)(12)$ 式可将 $(8)$ 式简化为$$P(y|x)=\\frac{exp(\\sum_k w_kf_k(y,x))}{\\sum_yexp(\\sum_k w_kf_k(y,x))}\\tag{12}\\propto exp(\\sum_k w_kf_k(y,x))$$ 2.3.4 参数学习以下采用梯度下降法来训练参数。 定义损失函数$$\\begin{aligned}L&amp;=-M\\&amp;=-log\\prod_{x,y}P(y|x)^{\\overline{P}(x,y)}\\&amp;=-\\sum_{x,y}\\overline{P}(x,y)logP(y|x)\\&amp;=\\sum_{x}\\overline{P}(x)logZ(x)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x)\\&amp;=\\sum_{x}\\overline{P}(x)log\\sum_{y}exp\\big(\\sum_k w_kf_k(y,x)\\big)-\\sum_{x,y}\\overline{P}(x,y)\\sum_k w_kf_k(y,x)\\end{aligned}\\tag{13}$$其中$\\overline{P}$为先验概率，可以通过统计方法得出。 对损失函数求导可得：$$\\frac{\\partial L}{\\partial w_k}=\\sum_{x,y}\\overline{P}(x)P(y|x)f_k(y,x)-\\sum_{x,y}\\overline{P}(x,y)f_k(y,x)\\tag{14}$$ 有了损失函数的导数之后就可以进行迭代优化参数，直到达到收敛条件：$$w_k:=w_k-\\eta\\cdot\\frac{\\partial L}{\\partial w_k}\\tag{15}$$梯度下降法的算法流程为：定义损失函数 $L(w)$、学习率 $\\eta\\rightarrow$计算梯度 $\\frac{\\partial L}{\\partial w_k}\\rightarrow$更新 $w\\rightarrow$计算梯度 $\\frac{\\partial L}{\\partial w_k}\\rightarrow$更新 $w\\rightarrow…\\rightarrow$达到收敛条件，得到训练后参数 $w$ 同样的，将训练好的CRF模型用于解码问题也可以采用维特比算法，此处将不再赘述。","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.779Z","path":"wiki/李宏毅机器学习/","text":"课程介绍 Learning Map model = a set of functions 机器学习三步走：define a set of function - goodness of function - pick the best function","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.778Z","path":"wiki/法学临时/","text":"教材第三页，以法律现象为研究对象的 第四页，法学的学科属性，第二段开始。。法学的研究对象 第五页第三行，法学具有阶级性。。。最后一行：自在的自然现象，客观事物的本质和特征不会，，， 本身不具有意识形态的特征。。。 法学研究多采用。。。。等社会科学方法。。。自然科学多采用。。。 底蕴。。。 第六页。。。求善。。。第三行以发现客观真理为最终目标 法学体系。。。第三行。。。互不相同而又相互联系的。。。 第八页：法学品格。法学不仅有自己。。研究对象。。。而且有自己的研究品格。。。法学是治国之学，为国家的基本治理提供。。。普遍推崇法治。。。 第九页第二段：法律人的概念 第十页：法律是人本之学。。。防止人性之恶。。。。 第十页第五行：权利本位。。。 法学是正义之学。。。与正义有着密不可分的关系 第十二页，第一行：法治文明的重要动力。其三。。。根本标准。。。 围绕正义问题。。。 法学是对正义的追求而发展起来的。。。 十六页：法学的产生（填空题）：人类理性的形成，较为广泛的立法，法学家的形成 二十页：马克思主义法学：这一段的第二行开始。。。马克思和恩格斯合创的，。。。标志着。。。初步形成。。诞生 二十一页。。。第一行。。。以唯物史观为基础，以。。。。建立了以人为中心。。。从而结束了。。。使得法学成为了一门真正的科学 三十五页：法的词源：法治的故斜体： 三十七页：中国古代法学的其它称谓：刑 三十八页：法律的特性。。。根植于其他社会关系中。。最后一页第一行，。。。法律以人的行为为调整对象。。。规范性的特征。。。具体表现为，。。一般性，适用性。。。。国家机关制定和认可的。。。国家意志性，统一性和普遍。。。 四十页：法律是规定人权利与义务的规范 应该怎样做，禁止怎样做。。。。往下第四行，法律具有力道行 国家强制力。。。最后两行要背 四十二页：法律的本质：法律的政治本质：经济本质：客观性， 四十六页：法律概念：”概而言之“开始。。。权威性。。。。法律性、明确性、多样性。。。最后一段第一句话 四十七页：第二段话： 法律概念是构成法律的细胞 四十八页：法律规则：最后一行 五十二页：法律规则的作用：法律规则是法律的主干部分 五十四页：法律原则：第二段：法律原则是指。。。综合性的。。。具有稳定性较高、覆盖面较广、具有弹性、。。。逻辑结构上比较简单、。。。等特征 六十一页：倒数第三段第二行：成文法即XXX 下一行法典是。。最具代表性的。。。 不成文法是未经国家立法机关制定不以法律条文为。。。主要有判例法和习惯法。。。 六十二页：填空：xxx是以宪法为核心的各种制定法。。。 六十六页：法律的类型：以XXX为标准，可以将法律划分为XXX 六十七页：接上 六十九页：倒数第三段：法律体系的定义。。。最后一段倒数第二行：法律部门的概念 七十页：第三行。。。划分法律部门的方式 当代中国的法律体系：问答题：由下面几个法律部门组成：宪法是这个法律体系的基础，是。。。的法律依据。。。指导意义；行政法是指调整。。。的总和。。；民商法是调整。。。的总和；商法是调整。。。的总和；刑法是。。。的总和；社会法是。。。的总和；经济法是。。。的总和；诉讼法是。。。的总和；环境法是。。。的总和；军事法是。。。；文化法。。。； 74页：填空：两大法系 八十九页：立法的界定：起点和第一步是。。。 立法的概念：广义和狭义 九十一页的最后一行：填空题：当代中国的立法体制：一元两极多层次 立法基本原则：XXX 九十六页：科学原则： 九十七页最后一行：立法的程序~九十八页第一行（填空） 101页：（填空）表决和通过法律案是全部立法程序中最具决定意义的阶段 立法的最后一段程序： 106页：倒数第三行：法律关系是成熟于。。。 107页：法律关系的内容是指：法律主体之间的权利与义务 111页：执法的概念 113页：执法的特征 116页：（问答题）执法的基本原则。。。合理性原则 司法： 122页：最后一行（填空，XXX是司法的根本，基本原则 124页：司法法治原则： 128页：守法行为的概念，守法及其理由 132页：违法的概念 152页：法律的人文精神 164页：法律是】","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.777Z","path":"wiki/读书笔记约法三章/","text":"读书笔记约法三章 “无他，唯手熟尔” 读书不做笔记，不常常温习约等于没学，重视笔记，舍得投入时间。 一曰：读完一章后提炼出主要知识点，并结合 自己的理解 进行记录。必要记忆的算法，代码片段，类、函数等也需要记录以便将来快速复习。 二曰：读的过程中发现每一章节的联系（理解作者这样编排内容的深意），及时对之前的笔记进行补充说明甚至重新理解。 三曰：进行二次阅读甚至多次阅读，修改理解不到位的、遗漏的知识点。 四曰：实际运用书中内容的时候将遇到的问题、积累的经验写在笔记中。","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.775Z","path":"wiki/大雾（上）复习笔记/","text":"大雾（上）复习笔记 考试消息 重点知识流体力学雷诺数：$R_e=\\frac{\\rho vd}{\\eta}$, 斯托克斯定律：$f=6\\pi\\eta rv$ 电介质 磁介质 ==矫正==：$i’=M \\times n_0$ 电偶极子 匀强电场中电偶极子收到的力矩： 匀强电场与电偶极子的相互作用能： 由负电荷指向正电荷 磁力矩： 电磁感应 导体 洛伦兹变换 转动惯量","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.773Z","path":"wiki/大二上 C++/","text":"C++基础 重点：const、引用类型 const强类型，类型转换需要显示说明 const float == float const const 限定成员函数：class obj &#123; int fc() const &#125; 定义一个常量，必须在定义时，赋初值； 常量不能在赋值号左边出现； 常量可以在赋值号右边出现； 常量的地址，只能赋值给一个常量指针 常量的地址，可以进行强制地址类型转换； 转换后，可以在赋值号左右都出现 volitile 修饰类型：易失性，访问该变量的时候直接访问内存单元而不会代换掉。 绕过const的方法：对其地址进行强制类型转换，再解析。 引用左右值 其他函数调用时按参数列表从右至左顺序压入栈区 C++ 类 关键字：深拷贝、浅拷贝 构造与析构若程序员没有主动给类定义构造函数，编译器自动给一个缺省的构造函数。一旦程序员定义了一个构造函数，系统将不会再给出缺省构造函数。除了系统缺省的构造函数外，只要构造函数无参或者参数有缺省值， 编译器会认为它就是缺省构造函数。缺省的构造函数同时只能有1个。 对象数组初始化构造器：ARRAY[5] = &#123;&#123;ARRAY[0]的构造参数&#125;, ...&#125; 析构函数一般用来释放体外空间，不用来释放本结点空间。 浅拷贝的危害当实例中有指针指向堆区内存时，浅拷贝得到的指针指向同一堆区空间，析构的时候就会相互影响 默认浅拷贝构造函数：Student(stu) 非法的复制构造函数：Student(Student a) 自定义深拷贝构造函数：Student(const Student &amp;a) new 和 delete new &lt;类型表达式&gt; delete &lt;指针&gt; delete sq; 指针指向非数组的单个实体 如sq指向对象，则自动调用析构函数，再释放对象所占的内存。 delete [ ] &lt;数组指针&gt; delete [] aq; 指针指向任意维的数组时使用 对所有对象(元素) 自动调用析构函数。 若数组元素为简单类型，则可用delete &lt;指针&gt;代替 delete 并不会销毁指针本身，安全起见要手动赋值NULL 成员指针 取成员的偏移地址： offsetof(类名, 成员名) 返回偏移字节数 &amp;&lt;类名&gt;::&lt;成员名&gt; 取成员指针（区别于普通的数据指针） 成员指针申明关键字：&lt;类名&gt;::* 成员指针调用：&lt;实例&gt;.*&lt;成员&gt; 移动构造A::A(A&amp;&amp; q)：适配临时值，优先于深拷贝。逻辑里面要完成体外空间的交接以及原体外空间指针的置空（防止析构出错）。 静态成员 在类体内声明，在类体外定义并初始化 静态函数成员没有this指针，若无参通常只应访问类的 静态数据成员和静态函数成员 静态函数成员的访问权限及继承规则同普通函数成员没 有区别，可以缺省参数、省略参数以及重载 构造函数、析构函数以及虚函数、常函数等必须有 this 参数，不能声明为static sizeof(&lt;obj&gt;)不包含静态数据成员 单继承单继承范式12345class &lt;派生类名&gt;: [&lt;派生控制符/继承方式&gt;] &lt;基类名&gt; &#123; &lt;派生类新定义成员&gt; &lt;派生类重定义基类同名的数据和函数成员&gt; &lt;派生类声明恢复基类成员访问权限&gt; &#125; 派生控制权限只降不升 回复控制权限可升可降，私有不可访 C++允许父类指针指向子类对象、父类引用子类对象， 无须通过强制类型转换， 编译时按父类说明的权限访问成员 虚函数 纯虚函数：virtual returnType funName(...) = 0 （相当于抽象函数），包含纯虚函数的类为抽象类，不论纯虚函数在体外是否有定义。 通过指针调用虚方法时才会查虚函数表。数据成员才会随着对象的构造滑入内存，方法不会。 多继承构造顺序 画出继承关系树，虚基类用方框框起来； 类的存储空间 运算符重载可重载类型 强制类型转换 地址类型转换 数据类型转换 单参数的构造函数具备类型转换作用，必要时能自动将 参数类型的值转换为要构造的类型。 用operator定义强制类型转换函数： operator 类型(…) 由于转换后的类型就是函数的返回类型， 强制类型转换函数不需要定义返回类。 模板 函数模板1234template &lt;模板形参表&gt; 返回类型 函数名 (参数表) &#123; &lt;函数体&gt;&#125; &lt;模板形参表&gt;可以包含一个或多个用逗号分开的参数 每一项均有关键字class或typename引导一个标识符 此标识符为模板参数，表示一种数据类型 类型可以是基本数据类型，也可以是类类型 参数表中至少有一个参数说明 参数在函数体中至少应用一次 类模板1234template &lt;模板形参表&gt; class 类名 &#123; &lt;类体说明&gt;&#125;","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.772Z","path":"wiki/Python/","text":"Python 入坑笔记 t = (1)定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 t = (1,) 动态类型语言，变量基于引用。 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 默认参数是程序创建伊始时自动创建的一个变量的引用，故而有义务使默认参数指向一个不变的对象，如整数类型，字符串类型，而不能是List这种可变类型。 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 Python 生成器&amp;迭代器生成器 列表生成器: [... for ... in ... if ...] Iterator 生成器: (... for ... in ... if ...) 生成式函数: yeild关键词，调用一次生成式函数就相当于创建了一个Iterator对象 迭代器 Iterable是可迭代对象，**Iterable是指那些可以用于for-in迭代的对象**，包括集合对象list,dict,set,map,str和generator Iterator是迭代器，**Iterator是指那些可以作用到next()上的对象**。Iterator是“惰性”的，只会按需迭代生成，可以用list()等转化为“非惰性”的列表。Iterator可能是一个无限的数据流。可以用iter()创建一个Iterator，Iterator可以用next()函数迭代。Iterator包括generator。 Iterator, Iterable均可以用于for-in循环。","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.770Z","path":"wiki/my/","text":"","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.769Z","path":"wiki/LatexTikz/","text":"Tikz 绘图学习笔记 注意事项: \\begin{tikzpicture} 环境下每一行命令结尾都要加分号; \\node, \\coordinate, \\draw 语法参考：https://zhuanlan.zhihu.com/p/84943429 \\node 描点, \\coordinate 拟点, \\draw 画线, \\fill 填充 参考网站: 路径与坐标：https://www.latexstudio.net/archives/51602.html node 控制：https://www.latexstudio.net/archives/51617.html 线条控制: https://www.latexstudio.net/archives/51622.html 示例代码: 12\\node at (A)[circle,fill,inner sep=1pt]&#123;&#125;;% 点名 属性","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.767Z","path":"wiki/Kotlin/","text":"Kotlin 学习笔记 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 $a 和 ${a.func()}我是真没话说。 完善的NULL检查机制 “!!, ?, ?:”（当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。方法是： “Type后 + ？”） 玩转for循环：可以方便的指定遍历的步长，范围。（ .., step, downTo, in, until) Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符==不属于==数值类型，是一个独立的数据类型。 支持二进制字面量，数值类型混入下划线增加语义性。 有些时候较小类型不会隐式转换成较大类型，需要手动调用 .toXXX() 来进行显示的类型转换。 和 golang 一样少了分号（这就是语法糖吗i了i了 if-else 语句与when语句等可以视为 ==表达式==（可赋值 when 与 -&gt; 符号构成强大的分支控制。 完全抛弃基本数据类型改用对象数据类型“。 “fun xxx() = xxx” 这个语法糖结合 if else, when 等特性可以打出漂亮的组合拳。 class 继承的时候对继承的父类后面一般要加括号（因为 java 继承中必调用父类构造函数）且此构造函数必调用主构造函数。 Java 与 Kotlin 访问修饰符对照表 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 语法糖: 原生支持数据类、单例类 （自动完成 toString(), hashCode(), equals() 等方法） Java 数据类代码示例 public class Cellphone &#123; String brand; double price; public Cellphone(String brand, double price) &#123; this.brand = brand; this.price = price; &#125; @Override public boolean equals(Object obj) &#123; if (obj instanceof Cellphone) &#123; Cellphone other = (Cellphone) obj; return other.brand.equals(brand) &amp;&amp; other.price == price; &#125; return false; &#125; @Override public int hashCode() &#123; return brand.hashCode() + (int) price; &#125; @Override public String toString() &#123; return &quot;Cellphone(brand=&quot; + brand + &quot;, price=&quot; + price + &quot;)&quot;; &#125; &#125; 12345- Kotlin 数据类代码示例- &#96;&#96;&#96; kotlin data class Cellphone(val brand: String, val price: Double) &#x2F;&#x2F;加一个data即可 Java 单例类代码示例 public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; public void singletonTest() &#123; System.out.println(&quot;singletonTest is called.&quot;); &#125; &#125; 123456789- Kotlin 单例类代码示例- &#96;&#96;&#96;kotlin object Singleton &#123; &#x2F;&#x2F;只需要用object代替class即可 fun singletonTest() &#123; println(&quot;singletonTest is called.&quot;) &#125; &#x2F;&#x2F;这里相当于一个静态方法 &#125; Kotlin class 类 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class Kotlin 标准函数 一系列定义于 Standard.kt 里的函数 参照表 函数 特点 代码段 let() 调用let的对象作为Lamda的参数，返回最后一行 obj.let &#123;(obj2 -&gt;) //obj2是obj&#125; with() 传入对象作为Lambda的上下文，返回最后一行 with(obj) &#123;//obj上下文&#125; run() 调用run的对象作为Lamda的上下文，返回最后一行 obj.run &#123;//obj上下文&#125; apply() 调用apply的对象作为Lamda的上下文，返回原对象 obj.apply &#123;//obj上下文&#125; Kotlin “静态方法调用” 单例类 objetc &#123;&#125; 伴生类 companion object &#123;&#125; 顶层方法 fun xxx()，可以被任意Kotlin代码直接调用，文件名作为类还可以用于java静态方法调用 @JvmStatic 注释，只能加注在单例类方法或伴生类方法上，使其编译成java静态方法","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.765Z","path":"wiki/Kotlin 进阶课堂/","text":"","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.764Z","path":"wiki/JavaLearning/","text":"2020-4-28 content: 对象与类，基本数据类型 int a, b; 则“a=b”表达式为int类型，不会自动转化为boolean类型 Java 的匿名内部类 //定义语法 new 父类构造器（实参列表) | 实现接口() //必须继承一个父类或接口 &#123; //匿名内部类的类体部分 &#125; /** * 规范： * 匿名类的声明是由java编译器自动派生自一个类实例创建表达式。 * 匿名类永远不能是抽象的。 * 匿名类总是隐式的final。 * 匿名类总是一个内部类；并且不能是static的。 */ 注意： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 内部类的class文件命名是：主类＋$＋内部类名 匿名类的class文件命名是：主类＋$＋(1,2,3….) class 对象 获取方式：有三种获得Class对象的方式： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class （类字面常量） 每个类的运行时的类型信息就是用Class对象表示的","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.762Z","path":"wiki/Java&Kotlin语法对照/","text":"Java &amp; Kotlin 的语法片段对照函数式 API Java 123456789101112//传入接口类型的实例（或继承了接口的匿名类）/* public interface Runnable &#123; void Run(); &#125; */new Thread(new Runnable() &#123; @Override public void run() &#123; //执行逻辑 &#125;&#125;).start() Kotlin 1234//传入Lambda表达式（单抽象的接口类型也可简化为Lambda表达式后传入）Thread &#123; //执行逻辑&#125;.start() 访问控制 修饰符 Java Kotlin pubilc 所有类可见 所有类可见（默认修饰符） private 当前类可见 当前类可见 protected 当前类，子类，同意包路径下的类可见 当前类，子类可见 default 同一包目录下的类可见（默认修饰符） 无 internal 无 同一模块下的类可见 Class 对象引用 语言 实例的Class对象 类的Class对象 Kotlin javaclass 类名::class.java Java (this).getclass() 类名.class","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.761Z","path":"wiki/Ideas/","text":"Williams’s Fantastic Ideas Github 有一个叫做 app ideas 的仓库有很多好的项目 根据图片定位到视频中的某一帧","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.759Z","path":"wiki/IDEA 学习笔记/","text":"IDEA基础功能概览： shortcut(edit, 代码片段, 功能), 版本控制(VCS: git, github, local history) Debug, javadoc generator, database, web deployment project&amp;module 等概念, 模板, 项目结构查询管理 Tips 代码段：main sout标准输出 soutv输出变量，soutm输出方法名，soutp输出命令行参数 变量名.sout输出变量 iter增强型for循环 引用名.for 迭代指定引用类型 实例名.fori顺序遍历 xxx.forr倒序遍历 ifn –”if xxx is null”, inn –”if not null” xxx.nn, xxx.ifn JavaLea 条件断点 –右键断点处 ctrl+u 查看表达式的值 Tools javadoc generator: Local: zh_CN; Other command line args: encoding UTF-8 -charset UTF-8 IDE 常用快捷键对照表（原始来源: https://www.jianshu.com/p/6267a7d76018 ) 操作 eclipse IDEA Visual Studio Code Sublime 编辑 Editing 格式化代码 Format Code Ctrl+Shift+F Ctrl+Shift+L Shift+Alt+F 无 删除行 Delete Line Ctrl+D Ctrl+Y Ctrl+Shift+K Ctrl+Shift+K 复制行 Copy Line Ctrl+C Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+Shift+Up/Down Ctrl+D Alt+Shift+Up/Down Ctrl+Shift+D 移动行 Move Line Alt+Up/Down Alt+Shift+Up/Down Alt+Up/Down Ctrl+Shift+Up/Down 换行 New Line Shift+Enter Shift+Enter Shift+Enter Ctrl+Enter 插入上行 Insert Line Above Ctrl+Shift+Enter Ctrl+Alt+Enter Ctrl+Shift+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+\\ Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Alt+Shift+Up/Down Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 优化导包 Optimize Imports Ctrl+Shift+O Ctrl+Alt+O 代码提示 Code Assist Alt+/ Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Alt+/比较low Ctrl+Shift+Enter 快速修复 Quick Fix Ctrl+1 Alt+Enter Quick Access Ctrl+3 Double Shift 参数信息 Parameter Info Alt+Shift+/还不如 Alt+/ Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Alt+Shift+N Ctrl+N 激活编辑器 Active Editor F12 Esc 全部小写 Ctrl+Shift+Y 全部大写 Ctrl+Shift+X 导航 Navigation 上/下一个Tab Ctrl+PgUp/PgDn Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Alt+Left/Right Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Q Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+L Ctrl+G 大纲/结构 Outline/Structure Ctrl+O Ctrl+F12 查看类层级 Type Hierarchy Ctrl+T 查看最近文件 Recent File Ctrl+E Ctrl+F6 Ctrl+E 跳到文件 Go To File Ctrl+Shift+N 切换视图 Switch View Ctrl+F7 重构 Refator 重命名 Rename Alt+Shift+R Shift+F6 提取变量 Extract Variable Alt+Shift+L 提取方法 Extract Method Alt+Shift+M 搜索 Find 查找下一个 Ctrl+K 查找上一个 Ctrl+Shfit+K 全局搜索 Ctrl+H","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.758Z","path":"wiki/IDE&Editor Shortcuts Query/","text":"各大 IDE &amp; Editor 快捷键对照表 操作 IntelliJ IDEA Visual Studio Code Visual Studio 编辑 Editing 格式化代码 Format Code Ctrl+Alt+L Shift+Alt+F 删除行 Delete Line Ctrl+Y Ctrl+Shift+K 选中行 Select Line Ctrl+L 复制行 Copy Line Ctrl+C Ctrl+C 剪切行 Cut Line Ctrl+X Ctrl+X 重复行 Duplicate Line Ctrl+D Alt+Shift+Up/Down 移动行 Move Line Alt+Shift+Up/Down Alt+Up/Down 换行 New Line Shift+Enter Shift+Enter 插入上行 Insert Line Above Ctrl+Alt+Enter Ctrl+Shift+Enter 注释 Comment Ctrl+/ Ctrl+/ 块注释 Block Comment Ctrl+Shift+/ Ctrl+Shift+/ 选择块 Block Selection Ctrl+W Ctrl+Shift+W Alt+Shift+Right/Left 选择相同内容 Alt+J Ctrl+D 优化导包 Optimize Imports Ctrl+Alt+O 代码提示 Code Assist Ctrl+Space Ctrl+Shift+Space 代码补全 Code Completion Ctrl+Shift+Enter 快速修复 Quick Fix Alt+Enter Quick Access Double Shift 参数信息 Parameter Info Ctrl+P 查看API文档 Quick Document Ctrl+Q 新建文件 New File Ctrl+N 激活编辑器 Active Editor Esc 全部小写 全部大写 导航 Navigation 上/下一个Tab Alt+Left/Right Ctrl+PgUp/PgDn 上/下一个 Ctrl+Alt+Left/Right 上一处修改的地方 Ctrl+Shift+Backspace 跳转到行 Go To Line Ctrl+G Ctrl+G 大纲/结构 Outline/Structure Ctrl+F12 查看类层级 Type Hierarchy 查看最近文件 Recent File Ctrl+E 跳到文件 Go To File 切换视图 Switch View 重构 Refator 重命名 Rename Shift+F6 提取变量 Extract Variable 提取方法 Extract Method 搜索 Find 查找 Find Ctrl+F Ctrl+L Ctrl+F 查找下一个 查找上一个 全局搜索 智能 Intellictual 重写 override Ctrl+O","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.757Z","path":"wiki/GOGOGO/","text":"CSGO 大🌏之路拐角定理离拐角（或障碍物）越近视野越受限，所以清点的时候要尽量站远点搜拐角。 同时也要避免长时间呆在距离拐角较近的地方蹲点/对枪/架枪。 蹲点的时候注意枪管长度不要暴露在外，必要的时候瞄墙藏枪管。 移动炮台架点遇敌人后不要当固定炮台，打完一个不要贪在原地架，对方知道了你的位置所以要及时移动免得被对面跟上来的peek掉（探头者优势）。移动的时候如果没发现有人跟着，可以考虑小身位看一下。 换弹切换换弹动作到了插入弹夹的时候可以切道具/切刀来争取时间（不需要拉栓了）。 但是换弹冷却时间总体是不会变的（切回来还需要时间），因此注意不要滥用（比如近距离对枪的时候换弹就没必要切来切去）。 假拆艺术CT 2 v 1 （已下包）局面，两个人一起走，打掉人之前最好不要单人拆包。这个时候可以假拆一下再跟着队友一起搜点打人再回来安心拆包（除非时间不够）。","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.754Z","path":"wiki/DiscreteMathematicNote/","text":"Discrete MatheMatic Note 离散数学笔记Author: BAIDIDate: from 2020-2-19 1 Logic and Proofs 逻辑和证明1.1 Propositional Logic connectives 逻辑联结词negationconjunction(合取) disjunction(析取) –inclusive/exclusive ..conditional statement/biconditional statement 1.2 Applications of Propositional Logic System Specification 系统规范说明 Boolean Logic 布尔逻辑 Logic Puzzles 逻辑谜题 Logic Circuits 逻辑电路 1.3 Propositional Equivalences tautology, contradiction, contingency logically equivalent ≡ ⇔ Law De Morgan’s Law¬(p ∧ q) ≡ ¬p ∨ ¬q¬(p ∨ q) ≡ ¬p ∧ ¬q other Law(check relative table)¬p ∨ q and p → q Distribute Lawp ∨ (q ∧ r) ≡ (p ∨ q) ∧ (p ∨ r) Law’s extension Law’s application Proposition’s Satisfiability and Problem’s Solution Soduka Puzzle’s solution 1.4 Predicates and Quantifiers 谓词和量词Predicates 谓词 basic notion:Propositional function P (命题函数P)n-place / n-ary predicates (n位/元谓词) 包含多个变量的谓词P(x1, x2…xn) –谓词+变量=命题Application–verify the correctness of a programme:Precondition(input) &amp; Postcondition(output expected) (前置条件 &amp; 后置条件） Quantifiers 量词Notions: Quantification 量化 Universal quantifier 全称量词 domain: domain of discourse 论域(universe of discouse 全体域) counterexample 反例 Existential quantifier 存在量词 Precedence 优先级 Resticted Domains 约束域 (约束域和条件，合取的等价关系) bound (被赋值或被量词联结）-绑定 scope -作用域 free -自由(未绑定的变量)Logic Equivalences Involving QuantifiersNotions: comma 逗号 Prolog –programming in logic Prolog fact / Prolog rule semicolon 分号Nested Quantifiers 嵌套变量Rules of inference 推理规则 argument 论证 valid 有效性 premise 前提 fallacy 谬误 argument form 推理形式 modus ponens 假言推理 （law of detachment 分离规则） hypothesis 假设 syllogism 三段论 contrapositive 逆否命题 instantiation 实例 arbitrary 任意的Itroduction to Proofs theorem 定理 axiom 公理 lemmma 引理 corollary 推论 conjecture 猜想 vacuous proof 空证明 trivial proof 平凡证明","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.753Z","path":"wiki/CMD 指令备忘/","text":"CMD 指令备忘 Process tasklist 列出所有进程 taskkill /pid xxx -f 杀死指定id process 找到占用端口的进程号：netstat -aon|findstr &quot;59207&quot; 查看进程所对应的应用程序：tasklist|findstr &quot;1396&quot; 编码方式 chcp + (num) 临时更改编码 437（英语） 65001（utf-8） 936（GBK）","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.751Z","path":"wiki/AndroidLearning/","text":"Android Studio 入坑笔记 Android Studio 自动创建 resource id 失败 重启 AS。 Sync with file system 同步一下？ 查看 R.java 中的 id 。Project 下依次打开app–&gt;build–&gt;generated–&gt;source–&gt;r–&gt;debug，在debug中的两个选项的子文件中分别有有一个R文件，既我们要找的R.java文件。（或者直接shift+shift查找R.java","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.749Z","path":"wiki/AmsMath踩坑/","text":"align 与 aligned 之争align,equation,gather本身提供数学环境，无需包围$$，且自动编号。aligned,gathered不提供数学环境，如果包含数学公式请包围$$，且不自动编号。split用于将分行自动编号的align,equation,gather内的内容改为按块自动编号。 括号一家 \\left(符号) and right. 自动匹配括号大小。 \\big,\\bigg,\\Big,\\Bigg+(符号)，手动匹配括号大小。 1234Andrew-&gt;China: Says HelloNote right of China: China thinks\\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks!","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.748Z","path":"wiki/《共产党宣言》读书笔记/","text":"资产者与无产者作为整个宣言的起始，本章先是简明扼要的阐述了资产阶级历史，指出了资本主义推翻封建主义对历史进程产生的积极影响（提高生产力）以及消极影响（引用书中的一句话：“总而言之，它用公开的、无耻的直接的、露骨的剥削代替了由宗教幻想和政治幻想掩盖着的剥削。”） 为了过渡到无产者和共产主义，又深刻地指出“资产阶级已经无力支配自己用法术召唤出来的魔鬼了”，这里“法术”应当指资本，而“魔鬼”则是资产阶级不断扩大生产招致的经济危机。《宣言》理性地分析了资产阶级无法克服经济危机的原因，提出了“资本主义的生产关系已经无法推动生产力的进一步发展”的观点（就像封建主义的生产关系无法适应生产力的发展而最终灭亡一样），还辛辣地指出资本主义多少显得有点黔驴技穷的补救措施（不断开拓新市场，榨干旧市场，压迫工人等）。 接着介绍了无产阶级登上历史舞台的过程，并且通过阐明主观条件（无产阶级受资产阶级压迫，必须要推翻资产阶级统治才能进一步谋求自身发展）与客观条件（无产阶级群体扩大，受教育因素影响掌握一定知识等）指出无产阶级夺取统治权力的时机已经成熟，最后以一句振奋人心的“资产阶级的灭亡和无产阶级的胜利是同样不可避免的。”结尾，再一次引起读者/听众的共鸣。 无产者和共产党人本章开篇首先阐述了共产党人同全体无产者的关系，以及同其他工人政党的关系和区别。共产党没有同无产阶级利益相悖的利益，和其他工人政党相比，共产党人的最近目的并无不同，然而共产党人却把握着更为先进的指导理论，并且作为无产阶级先锋队一直坚决地冲锋在工人运动的最前线，为了各个历史阶段工人运动的利益而战。 紧接着又阐明了共产主义的特征与目的，指出共产主义原理“不过是现存的阶级斗争、我们眼前的历史运动的真实关系的一般表述”。而后极具概括性地将共产党人的理论浓缩成一句话： 消灭私有制 本章还就资产阶级对于共产主义的种种责难进行了一一的回驳，澄清了共产主义性质与理想的真实形态，挥去了资产阶级为打压共产主义而散布的”烟雾弹“。有人责备共产主义试图剥夺个人所得，而《宣言》指出当下的私有财产不过是带有资产阶级性质的通过奴役他人积累起来的个人资本而已，而共产主义要做的不过是改变这种财产的社会性质，使之成为一种“社会力量”而非自私自利的“个人力量”；有人责备共产主义企图消灭家庭，而《宣言》指出当下的家庭关系同样带有阶级性质，并受资本的控制而，共产主义不过是要将家庭教育摆脱统治阶级的控制罢了；有人甚至说“共产主义是要取消祖国，取消民族”，而《宣言》首先精辟的指出当下无产阶级尚未获取政治统治，客观上来说压根没办法剥夺此种不存在的东西，因此这样的非难纯属刻意刁难。更何况无产阶级的统治加速各民族之间隔阂的消亡是顺应着历史潮流的，这点只要反观资产阶级革命道路上世界市场的开拓和形成便不难理解。 《宣言》在章节的末尾指出了无产阶级政治统治需要完成的“任务”：一步步夺取资产阶级掌握的资本，将生产工具集中在国家并尽可能快地提高生产力总量。此外还列出了部分具体措施，包括但不限于剥夺地产、废除继承权、集中运输业到国家手中等等方案。 社会主义的和共产主义的文献这一章节主要介绍了各个时期不同形态的社会主义和共产主义的内容，并且对其中的利弊做了详尽的讨论。 共产党人对各种反对党派的态度共产党人在共同的革命目标下（比如反对封建专制）与资产阶级保持合作关系，但时刻不忘告诉人们无产阶级与资产阶级从根本上一直以来都是对立的。在文章的末尾，《宣言》骄傲地宣布“共产党人不屑于隐藏自身的观点和意图。他们公开宣布：他们的目的只有通过暴力手段推翻现有社会制度才能达到。让统治阶级在共产主义革命面前发抖吧。无产者在这个革命中失去的只是锁链，他们获得的将会是整个世界！”。 读后感《共产党宣言》晓之以情，动之以理，对资产阶级和无产阶级历史条分缕析，表明了共产党人的奋斗目标，鼓舞了全世界的工人运动。文中不少地方的表达方式和结构安排都值得每一个宣讲者学习，同时通过阅读这本由马克思和恩格斯两位伟大的思想家和共产主义者合著的《共产党宣言》，对于共产主义的理解有了更进一步的理解。","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.746Z","path":"wiki/《第一行代码：Android》读书笔记（三）/","text":"《第一行代码：Android》读书笔记 (三) 为方便笔记，约定使用伪Kotlin语法： &lt;!ClassName&gt; 用来表示ClassName类的一个实例 &lt;Abstract&gt;或&lt;A&gt; 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法/类 &lt;Static&gt;或&lt;S&gt;写在方法(类)前用来表示该方法（类）是一个静态的方法/类 &lt;+&gt; 表示public方法 O 是override的缩略 XXX 表示待定的语法字符串 ... 表示前后代码段省略 丰富多彩的多媒体使用通知概览123456789101112131415classDiagram class NotificationManager &#123; +notify() +createNotificationChannel() &#125; class NotificationChannel class NotificationCompat &#123; +Builder() &#125; NotificationCompat --&gt; Notification: 创建 NotificationManager --&gt; NotificationChannel: 创建、管理 NotificationManager --&gt; Notification: 发送 Notification --* NotificationChannel: 对应 NotificationManager 类 创建：val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotifictionManager 备注：getSystemService() 是 Context 的一个用来获取系统服务方法。 NotificationChannel 类 每条通知都要属于一个对应的渠道。每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。 创建通知渠道12345678if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; // 通知渠道是v8.0新增的API，需要做下版本判别才能使用NotificationChannel val channel = NotificationChannel(channelId: String, channelName: String, importance) //构造通知渠道实例 渠道标识串 向用户显示的渠道名称 重要等级 &lt;!NotificationManager&gt;.createNotificationChannel(channel) //创建通知渠道 &#125; 通知渠道重要等级：IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN，用不同level构造的channel会有不同的表现，如HIGH级别的渠道会弹出通知。 Notification 类 可以在 Activity（较少）、Broadcast、Service 中创建 通知の构建与发送1234567891011121314//用AndroidX库的NotificationCompat类来构建通知要比原API兼容性更好val notification = NotificationCompat.Builder(context, channelId: String)//通知要对应唯一一个channel .setContentTitle(title: String) .setContentText(text: String) .setContentIntent(pi: PendingIntent)//点击事件 .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) .setAutoCancel(true)//点击通知后通知消失 //可以连缀多个set方法来赋予通知各种属性 .build()//构建 //通过管理器发送&lt;!NotificationManager&gt;.notify(id: Int, notification: Notification)// 通知的标识符 通知 通知属性(进阶)：.setStyle() 方法——让通知呈现富文本 123graph TD Style --&gt; BigPictureStyle; Style --&gt; BigTextStyle setStyle 举例12345//大图片.setStyle(NotificationCompat.BigPictureStyle().bigPicture( BitmapFactory.decodeResource(resources, R.drawable.big_image)))//长文字.setStyle( NotificationCompat.BigTextStyle().bigText(string: String) ) #### 点击事件 为通知设置点击事件：.setContentIntent(pi: PendingIntent) 构建PendingIntent123&lt;S&gt; PendingIntent.getXXX(ctx: Context, 0, intent: Intent, flag: Int): PendingIntent//para4用于确定PendingIntent的行为，一般可取0详，情查文档//XXX可以是Activity、Broadcast、Service 调用摄像头与相册From Camera123456789flowchart TB 获取对应的Uri对象 --&gt; 给intent传入Uri指定相片将写入的文件 intent机制呼出相机拍照 --&gt; 将拍摄的照片显示出来 subgraph 1 创建对应路径的File对象 --&gt; 获取对应的Uri对象 end subgraph 2 给intent传入Uri指定相片将写入的文件 --&gt; intent机制呼出相机拍照 end 相机实例123456789101112131415161718192021222324252627282930313233343536373839404142class MainActivity : AppCompatActivity() &#123; lateinit var imageUri: Uri lateinit var outputImage: File override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //step1 outputImage = File(externalCacheDir, &quot;output_image.jpg&quot;) if (outputImage.exists()) &#123; outputImage.delete() &#125; outputImage.createNewFile() //step2 imageUri = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; FileProvider.getUriForFile(this, &quot;com.example.cameraalbumtest.fileprovider&quot;, outputImage) &#125; else &#123; Uri.fromFile(outputImage) &#125;//从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个FileUriExposedException异常。 //而FileProvider则是一种特殊的ContentProvider，它可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。 //step3~4 val intent = Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;) intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri) startActivityForResult(intent, takePhoto) &#125; //step5 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) when (requestCode) &#123; takePhoto -&gt; &#123; if (resultCode == Activity.RESULT_OK) &#123;val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri)) imageView.setImageBitmap( bitmap) &#125; &#125; &#125; &#125; ...&#125; 代码中用到&quot;com.example.cameraalbumtest.fileprovider&quot;，需要在Manifest中注册。 fileprovider注册示例123456789&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; //固定不变 android:authorities=&quot;com.example.cameraalbumtest.fileprovider&quot; //与FileProvider.getUriForFile()第二个参数一致 android:exported=&quot;false&quot; //是否允许外部使用 android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data //指定Uri共享路径 android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; res/xml/file_paths.xml文件示例12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;my_images&quot; path=&quot;/&quot; /&gt; // 随意 指定共享目录&lt;/paths&gt; From Album12graph LR 发送请求Intent--&gt;接受并处理结果Result 相簿示例1234567891011121314151617181920212223242526class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; //*step1 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT) intent.addCategory(Intent.CATEGORY_OPENABLE) intent.type = &quot;image/*&quot; startActivityForResult(intent, fromAlbum) &#125; //step2 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; super.onActivityResult(requestCode, resultCode, data) when (requestCode) &#123; fromAlbum -&gt; &#123; if (resultCode == Activity.RESULT_OK &amp;&amp; data != null) &#123; data.data?.let &#123; uri -&gt; val bitmap = getBitmapFromUri(uri) imageView.setImageBitmap(bitmap) &#125; &#125; &#125; &#125; &#125; 播放多媒体文件音频概览12345678910111213classDiagramclass Activity &#123; getAssets();&#125;class AssetManager &#123; +openFd();&#125;class MediaPlayer &#123; +setDataSource(); +prepare();&#125;Activity--&gt;AssetManager: 创建AssetManager--&gt;MediaPlayer: 提供播放资源 MediaPlayer 类 MediaPlayer 可以用于播放网络、本地、app安装包中的音频 方法名 功能描述 setDataSource() 设置要播放的音频文件的位置 prepare() 在开始播放之前调用，以完成准备工作 start() 开始或继续播放音频 pause() 暂停播放音频 reset() 将MediaPlayer对象重置到刚刚创建的状态 seekTo() 从指定的位置开始播放音频 stop() 停止播放音频。调用后的MediaPlayer对象无法再播放音频 release() 释放与MediaPlayer对象相关的资源 isPlaying() 判断当前MediaPlayer是否正在播放音频 getDuration() 获取载入的音频文件的时长 AssetManager 类 app/src/main/assets 内的文件和子目录在项目打包时会一并打包到安装文件中。 AssetManager 就是用来管理asset内文件的工具类 音频示例播放安装包内音频12345678910111213141516171819202122232425262728293031323334353637383940class MainActivity : AppCompatActivity() &#123; private val mediaPlayer = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initMediaPlayer() play.setOnClickListener &#123; if (!mediaPlayer.isPlaying) &#123; mediaPlayer.start() // 开始播放 &#125; &#125; pause.setOnClickListener &#123; if (mediaPlayer.isPlaying) &#123; mediaPlayer.pause() // 暂停播放 &#125; &#125; stop.setOnClickListener &#123; if (mediaPlayer.isPlaying) &#123; mediaPlayer.reset() // 停止播放 initMediaPlayer() &#125; &#125; &#125; private fun initMediaPlayer() &#123; val assetManager = assets val fd = assetManager.openFd(&quot;music.mp3&quot;) mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length) mediaPlayer.prepare() &#125; override fun onDestroy() &#123; super.onDestroy() mediaPlayer.stop() mediaPlayer.release() &#125;&#125; 视频概论VideoView 类实际上是在MediaPlayer上的一层封装。 注意VideoView不支持播放asset文件，但可以播放app/src/main/res/raw下的文件（想到VideoView是一种View就不难理解）。 注意VideoView不适合做功能强大的视频播放器。 视频实例VideoView控件12345&lt;VideoView android:id=&quot;@id+videoView&quot; ...layout_width=... ...layout_height=... ... /&gt; VideoView类123456789101112131415161718192021222324252627282930313233/*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)*/ val uri = Uri.parse(&quot;android.resource://$packageName/$&#123;R.raw.video&#125;&quot;) //留意资源URI字符串格式 videoView.setVideoURI(uri) /* play.setOnClickListener &#123; if (!videoView.isPlaying) &#123; videoView.start() // 开始播放 &#125; &#125; pause.setOnClickListener &#123; if (videoView.isPlaying) &#123; videoView.pause() // 暂停播放 &#125; &#125; replay.setOnClickListener &#123; if (videoView.isPlaying) &#123; videoView.resume() // 重新播放 &#125; &#125; &#125;*/ override fun onDestroy() &#123; super.onDestroy() videoView.suspend()//释放VideoView占用的资源 &#125;&#125; 后台默默劳动者 Service安卓多线程Kotlin 多线程编程kotlin创建线程的三种方式123456789101112131415161718//1. 继承重写Thread()class MyThread: Thread() &#123; override fun run() &#123;...&#125;&#125;MyThread.start()//2-1. 用接口构造Thread()Thread(object: Runnable &#123; //注意这里是匿名内部类的写法 override fun run() &#123;...&#125;&#125;).start()//2-2. kotlin单抽象方法接口の简化版Thread&#123;/*Lambda*/&#125;.start()//3. 用kotlin内置顶层函数thread &#123; //logic&#125; 异步消息处理机制 Android 只能在主线程中改UI，因此在子线程中想要进行UI操作就需要异步机制 Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。 Handler主要用于发送和处理消息，发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。 MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象。 异步消息处理机制实例123456789101112131415161718192021222324252627class MainActivity : AppCompatActivity() &#123; val updateText = 1 //在主线程中创建一个Handler对象，当接收到Message时该对象的.handleMessage()就能在主线程中被调用 val handler = object : Handler() &#123; override fun handleMessage(msg: Message) &#123; // 在这里可以进行UI操作 when (msg.what) &#123; updateText -&gt; textView.text = &quot;Nice to meet you&quot; &#125; &#125; &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) changeTextBtn.setOnClickListener &#123; thread &#123; val msg = Message() msg.what = updateText handler.sendMessage(msg) // 在子线程将Message对象发送出去 &#125; &#125; &#125;//一趟下来Message从子线程辗转到了主线程&#125; 123456789101112131415classDiagramclass Message &#123; Int what Int arg1 Int arg2 Object obj &#x2F;&#x2F;以上字段用于携带信息&#125;class Handler &#123; +sendMessage(Message m) +post() +handleMessage(Message m)*&#125;Handler --&gt; Message: 发送Message --&gt; Handler: 处理 AsyncTask 类 重写四个方法，.execute()启动 解析AsyncTask类12345678&lt;A&gt; AsyncTask&lt;paramsType, progressType, resultType&gt; &#123;//注意三个泛型：参数类型 进度类型 结果类型 &lt;A&gt; onPreExecute() //后台开启前的初始化任务 &lt;A&gt; doInBackground(paramsType...) //后台任务：在子线程中运行 &lt;A&gt; onProgressUpdate(progressType...) //后台publishProgress(progressType...)后执行（通常在这改UI） &lt;A&gt; onPostExecute(resultType) //后台return后执行 &lt;+&gt; execute() //启动任务&#125; Service 基础Service 类Service类解析123456class Service &#123; onCreate() //创建时调用（第一次&lt;Activity&gt;.startService, bindService） onStartCommand(intent: Intent, flags: Int, startId: Int) //启动时调用(startServi...) onDestroy() //销毁时调用(stopService, unbindService) onBind(): IBinder //返回一个绑定接口便于Activity与Service交互&#125; 创建、启动与销毁Activity中启动与停止Service12345678startServiceBtn.setOnClickListener &#123; val intent = Intent(this, MyService::class.java) startService(intent) // 启动Service，会同时调用&lt;Service&gt;.onCreate和onStartCommand&#125;stopServiceBtn.setOnClickListener &#123; val intent = Intent(this, MyService::class.java) stopService(intent) // 停止Service Binder 类继承一个Binder，在类中编写自己的函数，通过onBind() 返回该实例给Activity，Activity中调用该实例的方法以实现Activity与Service的通信 12345678classDiagramclass IBinder&lt;&lt;interface&gt;&gt; IBinderclass MyBinder &#123; &lt;&lt;自定义&gt;&gt;&#125;IBinder &lt;|-- BinderBinder &lt;|-- MyBinder ServiceConnection 类123456classDiagramclass ServiceConnection &#123; &lt;&lt;Abstract&gt;&gt; onServiceConnected(ComponentName name, IBinder service) 启动绑定时调用 onServiceDisconnected(ComponentName name) 结束绑定时调用&#125; 绑定12345678910111213141516171819202122232425262728class MainActivity : AppCompatActivity() &#123; /* lateinit var downloadBinder: MyService.DownloadBinder private val connection = object : ServiceConnection &#123; override fun onServiceConnected(name: ComponentName, service: IBinder) &#123; downloadBinder = service as MyService.DownloadBinder downloadBinder.startDownload() downloadBinder.getProgress() &#125; override fun onServiceDisconnected(name: ComponentName) &#123; &#125; &#125;*/ override fun onCreate(savedInstanceState: Bundle?) &#123; … bindServiceBtn.setOnClickListener &#123; val intent = Intent(this, MyService::class.java) bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service &#125; unbindServiceBtn.setOnClickListener &#123; unbindService(connection) // 解绑Service &#125; &#125;&#125; Service 生命周期1234graph TB调用了n次startService--&gt;|停止Service|1次stopService既调用了startService又调用了bindService--&gt;|停止Service|stopService+unbindService同一个Service类只会存在一个实例 前台服务 Foreground 前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。 由于状态栏中一直有一个正在运行的图标，相当于我们的应用以另外一种形式保持在前台可见状态，所以系统不会倾向于回收前台Service。 启用方式：在&lt;Service&gt;.onCreat()中创建一条通知，大体上与1.1中创建通知的方式一样，不同的是不用通知管理器发送通知而是以startForeground(…)发送通知。 应用开启前台服务权限12345&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.servicetest&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt; …&lt;/manifest&gt; 前台服务实例12345678910111213141516171819202122class MyService : Service() &#123; … override fun onCreate() &#123; super.onCreate() val manager = getSystemService(Context.NOTIFICATION_SERVICE) asNotificationManager if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; val channel = NotificationChannel(&quot;my_service&quot;, &quot;前台Service通知&quot;, NotificationManager.IMPORTANCE_DEFAULT) manager.createNotificationChannel(channel) &#125; val intent = Intent(this, MainActivity::class.java) val pi = PendingIntent.getActivity(this, 0, intent, 0) val notification = NotificationCompat.Builder(this, &quot;my_service&quot;) .setContentTitle(&quot;This is content title&quot;) .setContentText(&quot;This is content text&quot;) .setSmallIcon(R.drawable.small_icon) .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.large_icon)) .setContentIntent(pi) .build() startForeground(1, notification) &#125; …&#125; IntentService 类12345678910111213classDiagramclass IntentService &#123; &lt;&lt;Abstract&gt;&gt; onHandleIntent(Intent intent)*&#125;class MyIntentService &#123; &lt;&lt;自定义&gt;&gt;&#125;class Service &#123; &lt;&lt;Abstract&gt;&gt;&#125;Service &lt;|-- IntentServiceIntentService &lt;|-- MyIntentService 作用：自动开启线程、自动停止服务","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.744Z","path":"wiki/《第一行代码：Android》读书笔记 (一)/","text":"《第一行代码：Android》读书笔记 (一)第一章 开启征程（概要） 项目结构与目录：page 17 - page 19 Log 方法与 Logcat 的完美结合 第二章 Kotlin 语法糖 同《Kotlin 学习笔记》一同食用最佳 《第一行》中出现的 Kotlin 特性预览表 主次构造函数 参数默认值 键值对传参 字符串内嵌表达式 init &#123;&#125;, constructor () &#123;&#125; fun xxx(str: String = &quot;&quot;) &#123;...&#125; xxx(str = &quot;...&quot;) &quot;$&#123;value&#125;&quot; 标准函数 Lambda 表达式 空指针检查 函数式 API let, run, apply, with &#123;para -&gt; ...&#125;, &#123;it.toString()&#125; ? ?. !!. ?: map.maxby &#123;/*Lambda*/&#125; 容器初始化 数据类 单例类 循环遍历 listOf(), mapOf(), setOf() data object for-in, until, downTo, step, l...r, 容器遍历 分支控制 条件控制 “不变为先” 访问控制 when () &#123;... -&gt; ...&#125;, if-else 语句/表达式 is (instanceof), else val, var, open class &quot;public by default&quot; 类型强转 repeat 函数 运算符重载 延迟初始化 as, as? repeat(/*num*/) &#123;/*Lambda*/&#125; operator 关键字 lateinit 初始化判断 密封类（与when语句一同使用） 扩展函数 无用参数 ::($变量名).isInitialized sealed class fun ClassName.funcName(...) : ... &#123;&#125; 下划线_ 函数类型 高阶函数 内联函数 可变参数 ClassName.(paraType, ...) -&gt; returnType 接受/返回函数类型/Lambda表达式的函数 inline noinline crossinline vararg Pair 类型 Smart Cast 自动转型 泛型 委托 A to B， 泛型 is Type 判断后实例自动向下转换类型 &lt;T&gt; 类委托、属性委托 第三章 Activity！所见即所得创建 Activity可变参数 创建和加载布局文件 layout 在 AndroidManifest.xml 中注册Activity 编写 Activity.kt 代码 （事件绑定，方法重写等） Activity 通信与切换 Intent 类 显式切换：Intent(上下文, 指定Activity 的 Class 类) 隐式切换：指定 action category，目标将会按照注册信息中的过滤条件响应 intent。 过滤条件：&lt;category&gt; &lt;action&gt; &lt;data&gt; 传参：.putExtra(), .getStringExtra() 启动方式：startActivity() //普通启动 startActivityForResult() //请求结果 - Activity 类 Result 结果 设置结果：setResult() 取回结果：override onActivityResult() Bundle 类 团队合作时用伴生类“静态方法”来启动 Activity 生命周期 返回栈的概念 思维导图 保存信息 Bundle 类型 onSaveInstanceState()，var savedInstanceState Activity 启动模式 standard 无检查，直接压栈 singleTop 检查栈顶 singleTask 解栈恢复 singleInstance 创建新栈 第四章 UI！！ 门面功夫 :-)控件 Widget 基本控件：TextView，EditView，Button，…… 自定义控件：编写class（注入布局，绑定事件）$\\rightarrow$ xml注册引入自定义控件 $\\rightarrow$ 引入控件 高级一点的控件：ListVIew, RecyclerView …基本原理撇清楚 Inflater 的作用：将xml格式的布局文件解析转化成View的实例 findViewById() 返回布局中指定id的View实例, 在Activity类中直接使用findViewById()相当于在当前Activitiy所加载的布局中寻找对应的view，而使用view.findViewById()则指定了寻找的区域是view内 留意Kotlin自动类型推导机制的使用场合，方法 *第五章 手机平板要兼顾，探究Fragment学习内容：Frag 生命周期，Frag 动态加载布局","tags":[],"categories":[]},{"title":"","date":"2020-11-06T08:35:32.742Z","path":"wiki/《第一行代码：Android》读书笔记 (二)/","text":"《第一行代码：Android》读书笔记 (二) 为方便笔记，约定使用伪Kotlin语法： &lt;!ClassName&gt; 用来表示ClassName类的一个实例 &lt;Abstract&gt;或&lt;A&gt; 写在方法(类)前用来表示该方法（类）是一个必须要给出实现的抽象方法/类 XXX 表示待定的语法字符串 ... 表示前后代码段省略 第六章 全局大喇叭！详解广播机制监听/接受广播 静态/动态注册BroadcastReciever，注意静态注册的接收器不能接受隐式Intent，还缺乏Activity上下文，但是能够在没启动的情况下收听到广播信号 静态注册：Manifest中注册；动态注册：Activity中注册，要记得自行销毁 发送自定义广播 Intent可以不但可以穿梭于不同Activity之间，也可以穿梭于不同Application之间（Broadcast） 分类：标准广播（一传多），有序广播（one by one，可截断） 第七章 数据存储：告别不持久 [👉 Java 流基础知识预备][1] 文件存储 适合存储一些简单的文本数据或二进制数据 Context 类提供 openFileOutput(...), openFileInput(...)用来打开/创建一个**/data/data//files/**目录下的文件，方法返回一个FileOutPutStream或FileInputStream对象，该对象可使用 Java流 的方式IO 举例：FileOutPut - OutputStreamWriter - BufferedWriter 文件存储实例1234567891011fun save(inputText: String) &#123; try &#123; val output = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE) val writer = BufferedWriter(OutputStreamWriter(output)) writer.use &#123; it.write(inputText) &#125; &#125; catch (e: IOException) &#123; e.printStackTrace() &#125;&#125; SharedPreferences 存储 SharedPreferences是使用键值对的方式来存储数据的，支持多种数据类型的存储 获取SharedPreferences: ①Context 的 getSharedPreferences() 与 Activity 的 getPreferences() 存储步骤 调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。 调用apply()方法将添加的数据提交，从而完成数据存储操作。 KTX库方法： KTX简化SharedPreferences存储1234getSharedPreferences(&quot;data, Context.MODE_PRIVATE&quot;).edit &#123; putString(&quot;name&quot;, &quot;Tom&quot;) putInt(&quot;age&quot;, 28)&#125; SQLite数据库存储 SQLite 是一种轻量简便的关系型数据库，可以用来存储复杂关系的数据 SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级（需要重写onCreate(), onUpgrate()） 两种CRUD方式：SQLiteDataBase类成员函数；SQL语句执行。 KTX库：contentValuesOf() 方法 数据库文件存储路径：/data/data/&lt;package name&gt;/databases/下 创建数据库 继承一个SQLiteOpenHelper的帮助类 解析SQLiteHelper帮助类12345678910111213141516//构造方案之一SQLiteOpenHelper(context: Context, name: String, cursor: Cursor, version: Int) &#123; // 上下文; 数据库名; 查询数据时用，一般传null; 版本号; /*抽象方法*/ &lt;A&gt; override fun onCreate(db: SQLiteDatabase) &#123; /*创建数据库时（name指定的数据库不存在时）调用*/ &#125; &lt;A&gt; override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123; /*升级数据库时（version改变时）调用*/ &#125; /*两个重要的实例方法*/ getReadableDatabase() getWritableDataBase() //打开（没有则创建）帮助类指定的数据库，返回一个可对数据库进行读写的对象(SQLiteDataBase)。当数据库不可写入时Readable将以只读方式打开，Writable将异常 //注意Kotlin中可以直接调用readableDatabase、writableDataBase属性&#125; 小插曲： 使用AS的Device File Explore和Database Navigate插件浏览虚拟机中的文件和数据库 #### 升级数据库 改变SQLiteOpenHelper类的version: Int参数，则下一次打开数据库的时候（用getReadableDatabase() getWritableDataBase()）会调用onUpgrade()方法。 最佳编写方式：针对不同版本编写不同逻辑 最佳实例12345678override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123; if (oldVersion &lt;= 1) &#123; db.execSQL(createCategory) &#125; if (oldVersion &lt;= 2) &#123; db.execSQL(&quot;alter table Book add column category_id integer&quot;) &#125;&#125; #### 数据库CRUD 直接执行 SQL 语句 execSQL()签名12345&lt;!SQLiteDataBase&gt;.execSQL(string: String, array: StringArray)//增删改 sql语句（含占位符）； 参数列表；&lt;!SQLiteDataBase&gt;.rawQuery(string: String, array: StringArray): Cursor//查 sql语句（含占位符）； 参数列表； 使用内置方法 123456789101112131415161718192021222324252627/*插入*/&lt;!SQLiteDataBase&gt;.insert(tableName: String, null, contentValues: ContentValues)//para2用于给某些为配值的可为空的列自动赋值为NULL；para3：ContentValue对象需要提供一系列put()方法的重载，用于向表中添加数据//ContentValues()构建实例val values1 = ContentValues().apply &#123; // 开始组装第一条数据 put(&quot;name&quot;, &quot;The Da Vinci Code&quot;) put(&quot;author&quot;, &quot;Dan Brown&quot;) put(&quot;pages&quot;, 454) put(&quot;price&quot;, 16.96) &#125; /*修改*/&lt;!SQLiteDataBase&gt;.updata(tableName: String, contentValues: ContentValues, where: String, paraArray: Array) //para3: 相当于sql中的WHERE部分；para4: 给WHERE中占位符分配参数的列表 /*删除*/&lt;!SQLiteDataBase&gt;.updata(tableName: String, where: String, paraArray: Array)/*查找*/&lt;!SQLiteDataBase&gt;.query(...): Cursor 方法的参数列表见下文/*调用query()返回一个Cursor对象*/&lt;!Cursor&gt;.moveToFirst()指针移动到第一个，成功返回True&lt;!Cursor&gt;.moveToNext()移动到下一个，成功返回True&lt;!Cursor&gt;.getXXX(Cursor.getColumnIndex())获取根据索引取出相应类型的值（XXX为某种Type）&lt;!Cursor&gt;.close()关闭指针 query()方法参数 对应SQL部分 描 述 table from table_name 指定查询的表名 columns select column1, column2 指定查询的列名 selection where column = value 指定where的约束条件 selectionArgs - 为where中的占位符提供具体的值 groupBy group by column 指定需要group by的列 having having column = value 对group by后的结果进一步约束 orderBy order by column1, column2 指定查询结果的排序方式 KTX库简化ContentValues的组装： 12val values = cvOf(&quot;name&quot; to &quot;Game of Thrones&quot;, &quot;author&quot; to &quot;George Martin&quot;, &quot;pages&quot; to 720, &quot;price&quot; to 20.85)db.insert(&quot;Book&quot;, null, values) SQLite 事务 (约定db: SQLiteDataBase) 首先用db.Transaction() 开启事务，之后在try块中编写数据库事务逻辑，结束时调用db.setTransactionSuccessful()，如果事务处理期间抛出异常将被catch捕获，事务将不被处理；如果顺利完成无Exception抛出，则在finally块中调用db.endTransaction()结束事务。 事务实例123456789101112131415161718replaceData.setOnClickListener &#123; val db = dbHelper.writableDatabase db.beginTransaction() // 开启事务 try &#123; db.delete(&quot;Book&quot;, null, null)// if (true) &#123;// // 在这里手动抛出一个异常，让事务失败// throw NullPointerException()// &#125; val values = cvOf(&quot;name&quot; to &quot;Game of Thrones&quot;, &quot;author&quot; to &quot;George Martin&quot;, &quot;pages&quot; to 720, &quot;price&quot; to 20.85) db.insert(&quot;Book&quot;, null, values) db.setTransactionSuccessful() // 事务已经执行成功 &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; db.endTransaction() // 结束事务 &#125; &#125; 第八章 跨程序共享数据，探究 ContentProviderAndroid 权限机制 普通权限申请：在AndroidManifest.xml中注册即可 普通权限申请12345&lt;manifest ...&gt;...&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;...&lt;/manifest&gt; 运行时权限（危险权限）申请：第一步同普通权限，第二步如下 危险权限申请流程：12345678//检查权限是否以及授予; 权限名（见图8-2）if(ContextCompat.checkSelfPermission(context: Context, permissionName: String) == PackageManager.PERMISSION_GRANTED) &#123;...&#125;//申请权限 权限列表 申请码（标识一次申请）ActivityCompat.requestPermissions(context: Context, permissions: StringArray, code: Int)/*权限申请结果返回时调用*/ /*申请码*/ /*申请的权限列表*/ /*申请结果*/override fun onRequestPermissionsResult (requestcode: Int, permissions: Array&lt;String&gt;, grantResults: IntArray) &#123;...&#125; //申请结果要与PackageManager.PERMISSION_GRANTED比较 Uri 类 内容URI为每一个app的ContentProvider中的数据提供了一个唯一标识符 内容URI字符串由协议声明、authority 和 path 组成（通配符：井号匹配任意长度数字；星号匹配任意长度字符串） 内容URI字符串格式12content://com.example.app.provider/table1/1 ←这是id协议部分 authority（包名.provider） path 解析Uri类1234//内容URI字符串解析为kotlin的Uri对象Uri.parse(uri: String): Uri//按‘/’分割Uri对象的内容URI的Path部分&lt;!Uri&gt;.getPathSegments(): List&lt;String&gt; ContentResover 类 获取实例：通过&lt;!Context&gt;.getContentResolver() ——Kotlin中即contentResolver属性 ContentResolver 的 CURD (将SQLiteDataBase对应的CURD中表名换成Uri即可) ContentProvider 类 ContentProvider实例需要实现其他app访问本app的CURD接口，而ContentResolver只是提供了一个访问其他程序的api；二者CURD 函数参数列表相同。 创建一个ContentProvider组件 使用AS的快捷方式 手动注册AndroidManifest.xml &lt;ContentProvider&gt;组件属性 exported：是否允许外部程序访问 enabled：是否启用 ContentProvider类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。 ContentProvider待实现方法1234567891011121314151617181920&lt;A&gt; ContentProvider() &#123; /*初始化ContentProvider的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示ContentProvider初始化成功，返回false则表示失败。*/ override fun onCreate(): Boolean /*从ContentProvider中查询数据。uri参数用于确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。*/ override fun query(uri: Uri, projection: Array&lt;String&gt;?, selection: String?, selectionArgs: Array&lt;String&gt;?, sortOrder: String?): Cursor? /*向ContentProvider中添加一条数据。uri参数用于确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。*/ override fun insert(uri: Uri, values: ContentValues?): Uri? /*更新ContentProvider中已有的数据。uri参数用于确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。*/ override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array&lt;String&gt;?): Int /*从ContentProvider中删除数据。uri参数用于确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。*/ override fun delete(uri: Uri, selection: String?, selectionArgs: Array&lt;String&gt;?): Int /*根据传入的内容URI返回相应的MIME类型。*/ override fun getType(uri: Uri): String?&#125; UriMatcher 类：方便匹配 ContentProvider 的 CURD 方法中的Uri（当调用UriMatcher的match()方法时，可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，就可以判断出调用方期望访问的是哪张表中的数据了。） 解析UriMatcher帮助类12345&lt;!UriMatcher&gt;.addURI(autority: String, path: String, code: Int)//添加匹配规则 返回代码（唯一标识匹配规则）&lt;!UriMatcher&gt;.match(uri: Uri): Int// 匹配对象 返回代码 MIME 字符串格式： 必须以vnd开头。 如果内容URI以路径结尾，则后接android.cursor.dir/；如果内容URI以id结尾，则后接android.cursor.item/。 最后接上vnd..。 URI: content://com.example.app.provider/table1MIME: vnd.android.cursor.dir/vnd.com.example.app.provider.table1 URI: content://com.example.app.provider/table1/1MIME: vnd.android.cursor.item/vnd.com.example.app.provider.table1","tags":[],"categories":[]},{"title":"Hello World","date":"2020-11-06T08:20:02.692Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}],"categories":[],"tags":[]}